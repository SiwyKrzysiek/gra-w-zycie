\documentclass{article}

\usepackage{polski} % Pozwala na użycie polskiego. Ustawia między innymi fontenc na T1
\usepackage[utf8]{inputenc} % Informuje o kodowaniu
\usepackage{enumitem}

\usepackage{xcolor}% http://ctan.org/pkg/xcolor
\usepackage{hyperref}% http://ctan.org/pkg/hyperref

\definecolor{LinkColor}{HTML}{1d5cc1}

\usepackage{tabto}

\usepackage{graphicx} % Pakiet do obrazów
\graphicspath{ {./Obrazy/} } % Folder, z którego będą brane obrazy

% Nie twórz nowych stron
\usepackage{etoolbox}
\makeatletter
% \patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}
\makeatother

\title{Specyfikacja implementacyjna -- Gra w życie}
\author{Krzysztof Dąbrowski i Jakub Bogusz}
\date{\today}

\begin{document}
\maketitle{}

\tableofcontents{}

\section{Podział na moduły}
Program będzie podzielony na współdziałające moduły. Pozwoli to na łatwiejszą modyfikację programu oraz dodawanie nowych funkcjonalności.

\begin{figure}
	\centering
	\def\svgwidth{\columnwidth}
	\includegraphics[width=13cm]{diagram_modolow.png}
\end{figure}	

\subsection{GameOfLife}
Główny moduł kontrolujący przepływ sterowania i danych między pozostałymi modułami.

\subsubsection{Funkcje}
\texttt{int main(int argc, char** args)} -- Punkt startowy programu. Z niej wywoływane będą kolejne funkcje. Przyjmować będzie 2 argumenty -- argumenty wsadowe programu:
\begin{itemize}[label={}]
	\item{} \texttt{int argc} -- ilość argumentów,
	\item{} \texttt{char** args} -- tablica napisów -- faktycznych argumentów wywołania programu.
\end{itemize}

\subsection{ArgumentsParser}
Moduł odpowiadający za interpretacje podanych wsadowo argumentów programu, konwersji ich oraz zapisu do utworzonej w tym celu struktury.

\subsubsection{Funkcje}
\texttt{Config parseArgs(int argc, char** argv)} -- będzie przetwarzać argumenty wsadowe programu podane w postaci flag na strukturę zawierającą ustawienia symulacji. Przyjmować będzie 2 argumenty -- argumenty wsadowe programu:
\begin{itemize}[label={}]
	\item \texttt{int argc} -- ilość argumentów,
	\item \texttt{char** args} -- tablica napisów, będących faktycznymi argumentami wywołania programu.
\end{itemize}

Zwracać będzie strukturę zawierająca ustawienia symulacji.

\subsection{BoardSaver}
Moduł odpowiadający za obsługę zapisu wyników działania programu w zależności od argumentów.

\subsubsection{Funkcje}
\texttt{void save(Board* b, Config c)} -- będzie uruchamiać konkretne funkcję zapisujące w zależności od podanych flag. Jako argument będzie przyjmować wskaźnik na strukturę zawierającą opis planszy:
\begin{itemize}[label={}]
	\item \texttt{Board* b} -- wskaźnik na strukturę zawierającą opis planszy.
\end{itemize}

\noindent{}\texttt{void saveTxt(Board* b, Config c)} -- Będzie zapisywać dany stan planszy w pliku tekstowym, mogącym w przyszłości służyć za plik wejściowy. Jako argument będzie przyjmować wskaźnik na strukturę zawierającą opis planszy:
\begin{itemize}
	\item \texttt{Board* b} -- wskaźnik na strukturę zawierającą opis planszy.
\end{itemize}

\subsection{GraphicsGenerator}
Moduł odpowiadający za obsługę zapisu wyników działania programu w zależności od argumentów.

\subsubsection{Funkcje}
\texttt{void savePng(char* data, Config c)} -- będzie generować plik .png będący reprezentacją planszy:
\begin{itemize}[label={}]
	\item \texttt{char* data} -- dane opisujące planszę, potrzebne do generacji pliku .png,
	\item \texttt{Config c} -- struktura zawierająca parametry pliku wyjściowego.
\end{itemize}
	
\noindent{}\texttt{void saveGif(char* data, Config c)} -- będzie generować plik .gif będący reprezentacją planszy:
\begin{itemize}[label={}]
	\item \texttt{char* data} -- dane opisujące planszę, potrzebne do generacji pliku .gif,
	\item \texttt{Config c} -- struktura zawierająca parametry pliku wyjściowego.
\end{itemize}

\subsubsection{Struktury}
Struktura zawierająca ustawienia symulacji: \\\\
\texttt{typedef struct\{}
\begin{itemize}[label={}, noitemsep, topsep=0pt]
	\item \texttt{int help;}
	\item \texttt{char* file;}
	\item \texttt{char* output\_dest;}
	\item \texttt{char* type;}
	\item \texttt{int number\_of\_generations;}
	\item \texttt{int step;}
	\item \texttt{int delay;}
\end{itemize}
\texttt{\}Config;}
\\\\
\texttt{help} -- informuje o tym czy ma być wyświetlana pomoc,\\
\texttt{file} -- informuje o tym jaka jest ścieżka do pliku wejściowego,\\
\texttt{output\_dest} --  informuje o tym jaka jest ścieżka dla pliku/plików wyjściowych,\\
\texttt{type} -- informuje o tym jaki jest typ zwracanych wyników,\\
\texttt{number\_o\_generations} -- informuje o tym ile pokoleń komórek zostanie wygenerowane,\\
\texttt{step} -- informuje o tym co ile pokoleń zapisywane będą dane wyjściowe,\\
\texttt{delay} -- informuje w jakich odstępach czasu mają się wyświetlać kolejne generacje komórek.\\

\subsection{BoardHandler}
Moduł definiujący operacje wykonywane na strukturze \texttt{Board}.

\subsubsection{Funkcje}

\texttt{Board* createRandomBoard(int x, int y)} -- Tworzy planszę o podanej wielkości z komórkami o losowych stanach.
\begin{itemize}[label={}]
	\item \texttt{int x} -- szerokość planszy
	\item \texttt{int y} -- wysokość planszy
\end{itemize}
Zwracany jest wskaźnik na nowy obiekt \texttt{Board} utworzony na stercie.

\vspace{5mm}
\noindent{}\texttt{void disposeBoard(Board *Board)} -- Zwalnia dynamicznie alokowane pola struktury \texttt{Board}. Powinna zostać wywołana przed zwolnieniem dowolnej zmiennej typu \texttt{Board}. Po zastosowaniu tej metody zmienna wskazana przez argument \texttt{Board} nie nadaje się już do użytku.
\begin{itemize}[label={}]
	\item \texttt{Board *Board} -- Adres planszy, która będzie zwalniana
\end{itemize}

\vspace{5mm}
\noindent{}\texttt{char* boardToString(Board *Board)} -- Generuje ciąg znaków reprezentujący stan wskazanej planszy.
\begin{itemize}[label={}]
	\item \texttt{Board *Board} -- Adres planszy, której reprezentacja ma zostać wygenerowana
\end{itemize}
Zwrócony napis należy po wykorzystaniu zwolnić.

\vspace{5mm}
\noindent{}\texttt{char* serializeBoard(Board *Board)} -- Generuje ciąg znaków reprezentujący wskazaną strukturę \texttt{Board}.
\begin{itemize}[label={}]
	\item \texttt{Board *Board} -- Adres planszy, której reprezentacja ma zostać wygenerowana
\end{itemize}
Zwrócony napis zawiera wszystkie niezbędne informacje do rekonstrukcji struktury na jego podstawie. Zwrócony napis należy po wykorzystaniu zwolnić.

\subsection{Board}
Moduł definiujący strukturę planszy.

\subsubsection{Struktury}
Typ wyliczeniowy zawierający możliwe stany pojedynczej komórki. \\
\texttt{typedef enum\{}
\begin{itemize}[label={}, noitemsep, topsep=0pt]
	\item \texttt{DEAD = 0,}
	\item \texttt{ALIVE = 1}
\end{itemize}
\texttt{\}CellState;}\\\\
\texttt{DEAD} -- Komórka jest martwa \\
\texttt{ALIVE} -- Komórka jest żywa

\vspace{5mm}

\noindent{}Struktura przechowująca stan pojedynczego pokolenia. \\
\texttt{typedef struct\{}
\begin{itemize}[label={}, noitemsep, topsep=0pt]
	\item \texttt{int sizeX;}
	\item \texttt{int sizeY;}
	\item \texttt{CellState *cells;}
\end{itemize}
\texttt{\}Board;\\} \\
\texttt{sizeX} -- Szerokość planszy \\
\texttt{sizeY} -- Wysokość planszy \\
\texttt{cells} -- Tablica zawierająca stany wszystkich komórek


\subsection{Simulator}
Moduł odpowiadający za przeprowadzenie właściwej symulacji zgodnie z regułami gry w życie.

\subsubsection{Funkcje}
\texttt{Board* simulate(Board* b, Config p)} -- będzie przeprowadzać symulacje\\ całej gry w życie:
\begin{itemize}[label={}]
	\item \texttt{Board* b} -- wskaźnik na strukturę zawierającą stan planszy,
	\item \texttt{Config p} -- struktura zawierająca ustawienia symulacji.
\end{itemize}
Zwracać będzie strukturę zawierająca końcowy stan planszy.

\vspace{5mm}

\noindent{}\texttt{Board nextGen(Board* b)} -- będzie generować planszę odpowiadającą następnemu pokoleniu komórek. Jako argument będzie przyjmować:
\begin{itemize}[label={}]
	\item \texttt{Board* b} -- wskaźnik na strukturę zawierającą stan planszy,
\end{itemize}
Zwracać będzie wskaźnik na strukturę zawierająca stan planszy w następnym pokoleniu.

\subsection{Loader}
Moduł odpowiedzialny za wczytanie planszy początkowej z pliku tekstowego i zapisanie jej do struktury.

\subsubsection{Funkcje}
\texttt{Board* load(char* path)} -- będzie przetwarzać plik wejściowy i zapisywać go do struktury. Jako argument będzie przyjmować:
\begin{itemize}[label={}]
	\item \texttt{char* path} -- ścieżka do pliku wejściowego,
\end{itemize}
Zwracać będzie wskaźnik na strukturę opisującą początkowy stan planszy.
\vspace{5mm}

\noindent{}\texttt{int* getSize(char* path)} -- będzie wczytywać rozmiar planszy zapisanej w pliku wejściowym:
\begin{itemize}[label={}]
	\item \texttt{char* path} -- ścieżka do pliku wejściowego,
\end{itemize}
Zwracać będzie dwuelementowy wektor zawierający rozmiary planszy początkowej.

\section{Kompilacja}
W celu automatyzacji procesu kompilacji wykorzystane zostanie narzędzie \textit{makefile}. Umożliwi ono przygotowanie scenariuszy kompilacji na różne środowiska.

\subsection{Środowisko testowe}
Środowisko to ma na celu optymalizację prędkości kompilacji i umieszczenie symboli pozwalających na sprawne debugowanie kodu w plikach wynikowych. Przy kompilacji testowej zostanie zdefiniowana stała \texttt{DEBUG}. Dzięki temu wykorzystując mechanizm kompilacji warunkowej możliwe będzie wyświetlenie dodatkowych informacji o działaniu programu w trybie testowym.

\paragraph{Lista flag:}
\begin{itemize}
	\item \texttt{-O0} -- Optymalizacja czasu kompilacji
	\item \texttt{-std=c11} -- Ustawienie standardu języka C
	\item \texttt{-Wall} -- Wypisywanie wszystkich ostrzeżeń
	\item \texttt{-g3} -- Umieszczenie pełnych symboli do debugowania
	\item \texttt{-D DEBUG} -- Ustawienie stałej preprocesora o nazwie \texttt{DEBUG}
\end{itemize}

\subsection{Środowisko produkcyjne}
Środowisko to ma na celu optymalizację zasobów wykorzystywanych przez program w trakcie działania.

\paragraph{Lista flag:}
\begin{itemize}
	\item \texttt{-Ofast} -- Optymalizacja zasobów kosztem czasu kompilacji
	\item \texttt{-std=c11} -- Ustawienie standardu języka C
	\item \texttt{-g0} -- Nie umieszczenie symboli do debugowania
\end{itemize}

\section{Testy}
Poprawność działania funkcji zawartych w modułach programu będzie testowana przy pomocy testów jednostkowych. W celu organizacji oraz uspójnienia testów zostanie wykorzystany framework \textbf{CUnit}.

\subsection{Stuktóra testów}
Testy zostaną podzielone na zestawy. Każdy zestaw będzie grupował testy dotyczące danej części projektu (najczęściej modułu, ale koniecznie). Dzięki podziałowi testów łatwiej będzie zidentyfikować kod wywołujący problemy.

\subsection{Planowane testy}

\paragraph{Test zamiany planszy na ciąg znaków} będzie polegał na ręcznym utworzeniu struktury planszy o konkretym stanie komórek. Następnie zostanie utworzona reprezentacja tekstowa planszy przy pomocy funkcji \\ \texttt{char* boardToString(Board *Board)}. Powstały w ten sposób tekst zostanie porównany z ręcznie wpisaną spodziewaną wartością.

\paragraph{Test parsowania planszy} będzie polegał na utworzeniu tymczasowego pliku zawierającego tekst w formacie pliku przechowującego stan planszy. Następnie zostanie wywołana funkcja \texttt{Board* load(char* path)}. Kolejnym krokiem będzie sprawdzenie czy szerokość, długość i wartości komórek wczytanej planszy są takie jak spodziewane. Jeśli te warunki zostaną spełnione wynik testu będzie pozytywny. Pod koniec testu usunięty zostanie plik tymczasowy.

%TODO: Napisać jaka funkcja jest wywoływana z modułu zasad
\paragraph{Test reguł} będzie weryfikował czy zasady generacji komórek następnego pokolenia przeważają poprawnie otrzymany obszar. W jego trakcie do modułu zasad zostanie przekazany obszar hipotetycznej planszy. Wynik realizacji reguł generacji następnego pokolenia na danym obszarze zostanie porównany ze spodziewanym obszarem. Jeśli wszystkie komórki będą miały identyczne stany test zakończy się pozytywnie.

\paragraph{Test symulacji} ma za zadanie zweryfikować proces wytworzenia całego nowego pokolenia na podstawie poprzedniego. W tym celu zostanie utworzona plansza o znanym stanie komórek. Będzie ona przekazana funkcji \texttt{Board simulate\\(Board b, Config p)}. Nowa plansza powstała w wyniku działania funkcji symulującej zostanie porównana ze spodziewanym stanem planszy. Jeśli jakakolwiek z komórek będzie różna między wynikiem symulacji a wartością spodziewaną test zakończy się niepowodzeniem.

\section{Test wczytania argumentów wsadowych} będzie polegał na utworzeniu napisu reprezentującego flagi podane przez użytkownika. Następnie zostanie wywołana funkcja \texttt{Config parseArgs(int argc, char** argv)}. Zwrócona struktura ustawień zostanie porównana pole po polu ze spodziewanym wynikiem. Jeśli wszystkie pola spodziewanych ustawień będą takie same jak tych powstały w wyniku parsowania flag programu test zakończy się powodzeniem.

\section{Biblioteki zewnętrzne}
Program będzie korzystał z bibliotek nie będących częścią standardu języka C. Umożliw to dostarczenie szerszej funkcjonalności.

\subsection{zlib.h}
Biblioteka zawierająca darmową implementację algorytmów kompresji i dekompresji \textit{deflate}. Jest ona wykorzystywana wewnętrznie przez bibliotekę \texttt{libpng.h}.

\subsection{libpng.h}
Biblioteka ta umożliwia tworzenie oraz odczytywanie plików graficznych takich jak \textit{png} czy \textit{gif}.

\subsection{cunit.h}
Jest to framework służący do tworzenia i uruchamiania testów jednostkowych. Zostanie wykorzystany do uspójnienia procesu testowania modłów programu.

\end{document}
